简历
1、熟练掌握Java基础知识，具有良好的编码习惯；

2、熟悉使用MySQL和Oracle数据库，了解存储引擎及索引优化；

3、熟练掌握SSM框架，理解Spring的IOC和AOP思想；
	IOC:在Spring框架中，开发者只需要描述这些对象以及它们之间的依赖关系，由Spring容器来负责实例化、组装和管理这些对象。这样做的好处是降低了组件之间的耦合度，使得代码更易维护、可测试和可扩展
	DI:spring 使用 javaBean 对象的 set 方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想
	AOP:允许开发者定义横切关注点，如日志、事务管理等，然后将这些关注点与应用的核心业务逻辑分离开来。在Spring框架中，AOP可以通过代理机制或者字节码增强等方式来实现，从而使得关注点的重用性和可维护性更加容易

4、熟练使用Redis，了解Redis不同数据类型的使用场景、持久化、缓存穿透、缓存雪崩、缓存击穿；
	String（字符串）：String类型是Redis最简单的数据类型，可以存储字符串、整数或者浮点数。它适合于缓存、计数器、分布式锁等场景。
	Hash（哈希）：Hash类型适合存储对象，比如用户信息、文章信息等。在需要存储结构化数据时，Hash类型是一个很好的选择。
	List（列表）：List类型适合存储有序的元素集合，可以用于实现消息队列、事件日志等功能。
	Set（集合）：Set类型适合存储不重复的元素集合，可以用于实现共同好友、共同兴趣爱好等功能。
	Zset（有序集合）：Zset类型在Set类型的基础上增加了一个分数字段，适合按照分数进行排序的场景，比如排行榜、范围查询等

	RDB持久化：RDB持久化会周期性地将内存中的数据快照写入磁盘，以便在Redis重启时恢复数据。RDB持久化适合用于备份和恢复数据，因为它生成的文件较小，适合用于大规模数据的快速恢复。
	AOF持久化：AOF持久化会将写命令追加到文件末尾，以便在Redis重启时重新执行这些命令来恢复数据。AOF持久化适合用于数据的持久性要求比较高的场景，虽然生成的文件较大，但可以保证数据更加完整和可靠

	缓存穿透（Cache Penetration）：
	当恶意请求或者非常罕见的请求查询一个不存在的数据时，由于缓存没有命中，请求会直接访问数据库，这样就会导致大量的请求直接打到了数据库上，从而引起数据库压力过大甚至宕机。为了解决缓存穿透问题，可以采用在查询结果为空时，也将空对象或者标记存入缓存中，或者使用布隆过滤器等技术来过滤掉无效的请求。

	缓存雪崩（Cache Avalanche）：
	缓存雪崩是指在设置缓存时，如果缓存的失效时间设置相近，导致大量缓存在同一时间失效，后续的请求全部落在了数据库上，造成数据库瞬时压力过大。为了避免缓存雪崩，可以通过合理地设置缓存失效时间，采用不同的失效时间点，或者使用热点数据永不过期等方式来分散缓存失效的时间。

	缓存击穿（Cache Breakdown）：
	缓存击穿是指某个热点数据突然失效或者被删除，而此时有大量的请求并发访问这个热点数据，导致大量请求直接打到数据库上，造成数据库压力过大。为了避免缓存击穿，可以采用加锁的方式来保证只有一个请求去加载数据到缓存，或者使用互斥锁等技术来避免并发访问

5、熟悉使用SpringBoot、SpringCloud等开源框架，了解SpringCloud常用组件；
	Nacos：
		服务发现和服务健康监测
		动态配置服务（维护的时候）
		心跳发送：服务实例会定期向Nacos发送心跳请求。通常情况下，这个间隔是可配置的，可以根据实际需求进行调整。
		心跳接收：Nacos会监听来自服务实例的心跳请求，并进行相应的处理。如果Nacos长时间没有接收到某个服务实例的心跳请求，就会认为该实例不再存活。
		存活状态更新：当Nacos收到服务实例的心跳请求时，会更新该实例的存活状态信息。通过这种方式，Nacos能够实时了解服务实例的状态，并及时做出相应的处理。
		服务实例管理：基于心跳机制，Nacos可以根据服务实例的存活状态来管理服务。例如，当某个服务实例不再存活时，Nacos可以将其从服务注册表中移除，避免将请求转发给无效的实例


	Gateway
		在网关中创建全局过滤器，限制用户直接访问内部接口及某些页面需登录才可使用，重定向到登录页面
		还有负载均衡的配置
		id: nacos-provider
          uri: lb://nacos-provider

	Feign：Feign是一个声明式的HTTP客户端，可以用于简化服务之间的调用，支持使用注解来定义接口和方法调用。
		是一个声明式的HTTP客户端，他的目的就是让远程调用更加简单。给远程服务发的是HTTP请求。简单来说就是调用不同服务的接口，获取数据，因为在传统项目中是不能跨服务获取数据的
		@FeignClient(value = "service-list",fallback = ListDegradeFeignClient.class)



6、熟练使用Linux操作系统下项目开发，了解Linux及Docker常用操作指令；
	Linux指令：
	ls：查看目录中的文件和文件夹。
	cd：切换当前工作目录。
	pwd：显示当前工作目录的路径。
	mkdir：创建一个新的目录。
	rm：删除文件或目录。
	cp：复制文件或目录。
	mv：移动文件或目录。
	cat：查看文件内容。
	grep：在文件中搜索指定的字符串。
	chmod：修改文件或目录的权限。
	chown：修改文件或目录的所有者。
	ps：查看运行中的进程。
	top：实时查看系统资源的使用情况。
	apt-get/yum：包管理器，用于安装、更新和卸载软件包。

	Docker指令：
	docker run：运行一个容器。
	docker stop：停止容器运行。
	docker start：启动已停止的容器。
	docker restart：重启容器。
	docker rm：删除容器。
	docker images：列出本地的镜像。
	docker pull：拉取远程镜像到本地。
	docker push：将本地镜像推送到远程仓库。
	docker exec：在运行的容器上执行命令。
	docker ps：列出正在运行的容器。
	docker logs：查看容器的日志输出。
	docker build：构建镜像

7、熟练使用Git、Github代码管理工具和Maven构建工具；

8、了解RabbitMQ消息中间件及其常见问题解决方法；
	Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker
	Virtual host:出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的vhost 		创建 exchange／queue 等
	Connection：publisher／consumer 和 broker 之间的 TCP 连接
		Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销
	Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point)， topic (publish-subscribe) and fanout (multicast)
	Queue：存储消息的容器，消息最终被送到这里，等待 consumer 取走
	Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据



9、了解Java多线程及线程池的基本原理；
    wait：释放资源锁，Object类！
	sleep：不释放资源锁，Thread类！

	创建线程：
        1. 继承Thread：java是单继承，资源宝贵，要用接口方式断
        2. 实现Runable接口
        3. 实现callable接口
              1.创建Callable的实现类,并冲写call()方法，该方法为线程执行体，并且该方法有返回值
              2.创建Callable的实例，并用FutuerTask类来包装Callable对象，该FutuerTask封装了Callable对象call()方法的返回值
              3.实例化FutuerTask类，参数为FutuerTask接口实现类的对象来启动线程
              4.通过FutuerTask类的对象的get()方法来获取线程结束后的返回值
        4. 线程池
            1. 线程池的优点：
                        1. 线程复用：线程池中的线程可以重复使用，避免频繁的创建和销毁线程，降低系统
                            开销
                        2. 控制最大并发数：线程池可以对最大并发数进行控制，避免大量的线程同时执行，导致
                            系统崩溃
                        3. 管理线程：线程池可以对线程进行管理，比如：终止、暂停、恢复等
            2. 线程池的创建：
                1. 创建ThreadPoolExecutor对象，并指定核心线程数、最大线程数、线程存活时间、
                    线程工厂、任务队列等参数
                2. 调用execute()方法提交任务
                3. 调用shutdown()方法关闭线程池
            3. 线程池的参数：
                1. 核心线程数：线程池创建时，会创建一些核心线程，这些线程不会被回收，除非线程
                    池关闭
                2. 最大线程数：线程池创建时，会创建一些核心线程，这些线程不会被回收，直到线程
                    池关闭
                3. 线程存活时间：线程池创建时，会创建一些核心线程，这些线程不会被回收，直到线程
                    池关闭
                4. 线程工厂：线程池创建时，会创建一些核心线程，这些线程不会被回收，直到线程
                    池关闭
                5. 任务队列：线程池创建时，会创建一些核心线程，这些线程不会被回收，直到线程
                    池关闭
            4. 线程池的执行流程：
                1. 线程池创建时，会创建一些核心线程，这些线程不会被回收，直到线程池关闭
                2. 线程池创建时，会创建一些非核心线程，这些线程不会被回收，直到线程池关闭
                3. 当线程数小于核心线程数时，会创建核心线程执行任务
                4. 当线程数大于核心线程数时，会创建非核心线程执行任务
                5. 当线程数大于最大线程数时，会执行拒绝策略
                6. 当线程池中的线程执行完一个任务后，会继续获取新的任务，直到线程池关闭
            5. 线程池的关闭：
                1. 调用shutdown()方法关闭线程池，线程池不再接收新任务，但会继续执行完已提交
                    的任务
                2. 调用shutdownNow()方法关闭线程池，线程池不再接收新任务，并中断所有正在执行的
                    任务
            6. 线程池的缺点：
                1. 线程池中的线程可能会存在饥饿现象
                2. 线程池中的线程可能会存在死锁现象
                适用于生存周期较短的的任务，不适用于又长又大的任务。
                不能对于线程池中任务设置优先级。
                不能标识线程的各个状态，比如启动线程，终止线程。
                对于任意给定的应用程序域，只能允许一个线程池与之对应。
                线程池所有线程都处于多线程单元中，如果想把线程放到单线程单元中，线程池就废掉了

    ReentrantLock与Synchronized对比：
        1. 两者都是可重入锁

        都是可重入锁、独占锁
    ReentrantLock:
        1. 公平锁：支持公平机制，先等待的线程先获得锁
        2. 非公平锁：不支持公平机制，支持快速获取锁
        3. 可重入锁：支持线程多次获取锁
        4. 独占锁：一次只能被一个线程占有
        5. 互斥锁：一次只能被一个线程占有
        6. 实现原理：
            1. 加锁：
                1. 获取锁：获取锁失败，线程进入阻塞状态
                2. 释放锁：释放锁成功，线程进入就绪状态
            2. 解锁：
                1. 获取锁：释放锁成功，线程进入就绪状态
                2. 释放锁：释放锁失败，线程进入阻塞状态
        6. 应用场景：
            1. 读写锁：读读不互斥，读写互斥，写写互斥
            2. 公平锁：
                1. 优点：先来先服务
                2. 缺点：吞吐量下降
            3. 非公平锁：
                1. 优点：吞吐量增大
                2. 缺点：可能出现饥饿现象

    线程池：




    线程同步：
        1. 线程同步：

      可重入锁
      可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁。
      	好处：可以一定程度避免死锁！




	多线程的基本原理：
	在Java中，可以通过继承Thread类或实现Runnable接口来创建线程。创建线程后，可以调用start()方法启动线程，使其进入就绪状态，等待系统调度执行。每个线程有自己的栈空间，可以独立运行，并且可以共享进程的资源，如堆空间等。

	线程的调度和同步：
	Java的线程调度由操作系统的线程调度器完成，它决定了线程的执行顺序和时间片分配。在多线程编程中，需要考虑线程的同步与互斥，以避免多个线程访问共享资源时发生数据不一致的情况。可以使用synchronized关键字、Lock对象、volatile关键字等机制来实现线程的同步和互斥。

	线程池的基本原理：
	线程池是一种管理和复用线程的机制，它可以在需要时创建新线程，并在线程完成任务后将其返回到线程池中，以供下次使用。Java中的线程池由Executor框架提供，其中常用的实现类是ThreadPoolExecutor。通过线程池，可以控制并发线程的数量，减少线程创建和销毁的开销，提高系统的性能和稳定性。

	线程池的工作原理    ：
	当一个任务提交到线程池时，线程池会根据预先配置的参数（如核心线程数、最大线程数、任务队列等）来决定是否创建新线程执行任务，还是将任务加入到任务队列中等待执行。线程池会根据工作负载动态调整线程数量，以保持系统的平衡和高效运行

10、了解JVM体系结构及常用GC算法；
	JVM体系结构
		a.	类加载器ClassLoader
        				- 启动类加载器（Bootstrap）C++

        				  负责加载$JAVA_HOME中jre/lib/**rt.jar**里所有的class，由C++实现，不是ClassLoader子类

        				- 扩展类加载器（Extension）Java

        				  负责加载java平台中**扩展功能**的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

        				- 应用程序类加载器（AppClassLoader）Java

        				  也叫系统类加载器，负责加载**classpath**中指定的jar包及目录中class

        				- 用户自定义加载器  Java.lang.ClassLoader的子类，用户可以定制类的加载方式

        			双亲委派机制：重点！
        				加载类的时候，逐层向上找！找不到在向下找！ 还是找不到则会抛出异常！

        				作用：防止内存中出现多份同样的字节码!

        			b.	**Execution Engine**执行引擎负责解释命令，提交操作系统执行。

        			c.	本地接口Native Interface
        					由native 修饰： 底层C,C++ 实现的！

        			d.	Native Method Stack
        					它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。

        			e.	PC寄存器
        					**用来存储指向下一条指令的地址**

        			f.	Method Area方法区{非堆}	重点！
        					共享区间**。
        					**静态变量+常量+类信息(构造方法/接口定义)+运行时常量池**存在方法区中
        					But
        					**实例变量存在堆内存**中,和方法区无关
        					Stu stu=new Stu(1，"zhang3");
        					stu中地址在栈中，(1，"zhang3")在堆中
        			g.	栈：
        					栈内存，生命周期与线程一致，不存在垃圾回收！
        					存储：**8种基本类型的变量+对象的引用变量+实例方法**	重点！

        					运行原理：
        						遵循“先进后出”或者“后进先出”原则。

        					"Exception in thread "main" java.lang.StackOverflowError"
        						细心，细心，细心！看代码！


		运行时数据区域（Runtime Data Area）：包括方法区、堆、栈、程序计数器和本地方法栈等。
			方法区（Method Area）：存储类的结构信息、静态变量、常量等数据。
			堆（Heap）：存储对象实例和数组，也是垃圾收集器管理的主要区域。
			    堆划分：
                			新生区：
                				伊甸区（Eden space）和幸存者区（Survivor pace）幸存0区 幸存1区 {from ，to}
                				创建的对象都在伊甸区：
                				当伊甸园区空间满的时候，程序还需要创建对象时。JVM 就会产生调用回收 普通的GC! 然后将剩下存活的对象放入From 区！

                				Minor GC GC过程：
                				**复制** -> **清空** -> **互换**
                				部分对象会在From和To区域中复制来复制去,如此交换15次，进入养老区！
                			养老区：
                				经过15次普通GC 之后的对象！
                				养老区满的时候，发生FULL GC{MajorGC}！ 如果依然无法存储对象，此时会发生！就会产生OOM异常“OutOfMemoryError"！
                					原因：
                						1.	可能堆内存不够，可以通过参数条件 -Xms -Xmx
                						2.	存储大量的大对象！这些对象不会被回收！
                			永久区：
                				永久代是方法区(相当于是一个接口interface)的一个实现！ 方法区也叫非堆！
                				永久代与元空间的最大区别之处？
                				**永久代使用的是jvm的堆内存**，但是java8以后的**元空间**并不在虚拟机中而是**使用本机物理内存**。因此，默认情况下，元空间的大小仅受本地内存限制。
                堆调优：
                			对应的参数：
                				| 参数                | 备注                                                   |
                				| ------------------- | ------------------------------------------------------ |
                				| -Xms                | 初始堆大小。只要启动，就占用的堆大小，默认是内存的1/64 |
                				| -Xmx                | 最大堆大小。默认是内存的1/4                            |
                				| -Xmn                | 新生区堆大小                                           |
                				| -XX:+PrintGCDetails | 输出详细的GC处理日志                                   |
                			System.gc(); 调用它之后，是否会立即执行垃圾回收？
                				不会！
			栈（Stack）：存储局部变量、操作数栈、方法出口等数据。
			程序计数器（Program Counter Register）：记录正在执行的虚拟机字节码指令地址。
			本地方法栈（Native Method Stack）：为执行本地（Native）方法服务。
			执行引擎（Execution Engine）：包括解释器、即时编译器（JIT）、垃圾收集器等部分，负责执行Java字节码。

    GC：分代收集算法
    		垃圾判定：
    			1.	引用计数法！
    				优点：
    				- 简单，高效，现在的objective-c、python等用的就是这种算法。
    				缺点：
    				- 引用和去引用伴随着加减算法，影响性能
    				- 很难处理循环引用，相互引用的两个对象则无法释放。
    				**因此目前主流的Java虚拟机都摒弃掉了这种算法**。
    			2.	可达性分析算法!
    					判断一个对象是否可以被回收：
    						这个对象被标记两次！
    							第一次标记：不在 GC Roots 链中，标记为可回收对象。
    							第二次标记：判断当前对象是否实现了finalize() 方法，如果没有实现则直接判定这个对象可以回收，
    								如果实现了就会先放入一个队列中。并由虚拟机建立一个低优先级的程序去执行它，随后就会进行第二次小规模标记，
    								在这次被标记的对象就会真正被回收了！
    			3.	四种引用：
    					强引用：	gc 不会动！
    					软引用：	当内存快溢出的时候，才会进行回收！
    					弱引用：	在下一次垃圾收集之前。
    					虚引用：	在回收之前，会得到一个通知！

    			4.	垃圾回收算法：
    					**GC优化 很多时候就是指减少Stop-the-world发生的时间，从而使系统具有高吞吐 、低停顿的特点。**
    					a.	复制算法:
    							优点：
    								高效，没有内存碎片！
    							缺点：
    								浪费内存空间
    								想要存活率低的对象，克服50%内存的浪费！
    							在新生区！
    					b.	标记清除：
    							优点：
    								相对复制算法来讲节省了内存空间！
    							缺点：
    								会扫描两次
    								有内存碎片产生
    							在养老区！
    					c.	标记压缩:
    							优点：
    								内存存活对象排列整齐，同样相对复制算法来讲，节省空间！
    							缺点：
    								会扫描两次！
    								存活对象过多，那么整理过程效率就会变低！
    							在养老区！
    							老年代一般是由[标记清除]或者是[标记清除与标记整理]的混合实现
    					d.	分代收集算法(Generational-Collection)
    							老年代一般是由[标记清除]或者是[标记清除与标记整理]的混合实现
    							新生区复制算法！
    		垃圾收集器：
    			1.	Serial/**Serial Old**收集器
    					串行：
    						新生代：复制算法！
    						老年代：标记压缩！
    			2.	ParNew收集器：
    					并行：
    						新生代：复制算法！
    					串行：
    						老年代：标记压缩！
    			3.	Parallel / Parallel Old 收集器：
    					可以通过参数来设置吞吐量！
    						新生代复制算法
    						老年代标记-压缩
    			4.	CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器
    					整个过程分为4个步骤，包括：
    						- 初始标记（CMS initial mark）
    								初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快
    								Stop The World
    						- 并发标记（CMS concurrent mark）
    								并发标记阶段就是进行GC Roots Tracing的过程
    						- 重新标记（CMS remark）
    								重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
    								Stop The World
    						- 并发清除（CMS concurrent sweep）
    						老年代收集器；
    					**优点**: 并发收集、低停顿
    					**缺点**: 产生大量空间碎片、并发阶段会降低吞吐量
    					"CMS收集器的内存回收过程是与用户线程一起并发地执行"
    					运行时机：在内存快要耗尽的时候运行！否则会失败！
    			5.	G1收集器：
    					特点：
    						1.	并行与并发:
    								G1收集器仍然可以通过并发的方式让java程序继续执行。
    						2.	分代收集：
    								G1可以自己管理新生代和老年代了。
    						3.	空间整合：
    								复制算法，标记压缩 这两种算法都意味着G1运作期间不会产生内存空间碎片
    						4.	可预测的停顿：
    								消耗在垃圾收集上的时间不得超过N毫秒！
    					G1 收集器的运作大致可划分为以下几个步骤：
    						1、初始标记（Initial Making）
    								标记一下GC Roots能直接关联到的对象，停顿时间较短!
    						2、并发标记（Concurrent Marking）
    								并发标记阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活对象，这一阶段耗时较长但能与用户线程并发运行！
    						3、最终标记（Final Marking）
    								而最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但可并行执行
    						4、筛选回收（Live Data Counting and Evacuation）
	常用的垃圾收集（GC）算法包括以下几种：
		标记-清除算法（Mark-Sweep）：标记阶段标记所有存活的对象，清除阶段回收未标记的对象空间，存在内存碎片问题。
		复制算法（Copying）：将堆空间划分为两个相等的区域，每次只使用其中一个区域，当这个区域用完后，将存活对象复制到另一个区域，然后清除当前区域中的所有对象。
		标记-整理算法（Mark-Compact）：标记存活对象，然后将存活对象向一端移动，最终清理掉边界外的内存，解决了标记-清除算法的内存碎片问题。
		分代算法（Generational）：将堆空间划分为新生代和老年代，根据对象存活周期采用不同的回收算法，新生代使用复制算法，老年代使用标记-清除或标记-整理算法。
		并发标记清除算法（Concurrent Mark-Sweep）：在标记和清除阶段尽量减少停顿时间，以提高系统的吞吐量和响应速度