nacos
客户端启动时会将当前服务的信息包含ip、端口号、服务名、集群名等信息封装为一个Instance对象，然后创建一个定时任务，每隔一段时间向Nacos服务器发送PUT请求并携带相关信息。
nacos服务器端在接收到心跳请求后，会去检查当前服务列表中有没有该实例，如果没有的话将当前服务实例重新注册，注册完成后立即开启一个异步任务，更新客户端实例的最后心跳时间，如果当前实例是非健康状态则将其改为健康状态。
nacos 启动类 注解 enablediscoveryclient 服务器提供者把自己的协议地址注册nacos server 服务器消费者需要从nacos server 上查询提供者地址（服务名称）
nacos server 需要感知到服务提供者的上下线变化 
服务消费者需要动态感知nacos server 端服务地址的变化
1、Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
2、Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；
3、Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；
4、Feign：基于Ribbon和Hystrix的声明式服务调用组件；
5、Zuul：API网关组件，对请求提供路由及过滤功能。
springboot三大核心注解是@Configuration 被标注的类在配置文件中配置，@EnableAutoConfiguration 自动配置和@ComponentScan 扫描Bean
心跳定时任务创建完成后，通过POST请求将当前服务实例信息注册进nacos服务器。
nacos服务器端在接收到注册实例请求后，会将请求携带的数据封装为一个Instance对象，然后为这个服务实例创建一个服务Service，一个Service下可能有多个服务实例，服务在Nacos保存到一个ConcurrentHashMap中Map(namespace,Map(group::serviceName, Service))； 。
nacos将实例添加到对应服务列表中会根据AP和CP不同的模式，采用不同协议。
CP模式就是基于Raft协议（通过leader节点将实例数据更新到内存和磁盘文件中，并且通过CountDownLatch实现了一个简单的raft写入数据的逻辑，必须集群半数以上节点写入成功才会给客户端返回成功）
AP模式基于Distro协议（向任务阻塞队列添加一个本地服务实例改变任务，去更新本地服务列表，然后在遍历集群中所有节点，分别创建数据同步任务放进阻塞队列异步进行集群数据同步，不保证集群节点数据同步完成即可返回）
nacos在将服务实例更新到服务注册表中时，为了防止并发读写冲突，采用的是写时复制的思想，将原注册表数据拷贝一份，添加完成之后再替换回真正的注册表。
nacos在更新完成之后，通过发布服务变化事件，将服务变动通知给客户端，采用的是UDP通信，客户端接收到UDP消息后会返回一个ACK信号，如果一定时间内服务端没有收到ACK信号，还会尝试重发，当超出重发时间后就不在重发。
客户端通过定时任务定时从服务端拉取服务数据保存在本地缓存。

