JVM:
	1.	**JVM**是运行在操作系统之上的，它与硬件没有直接的交互
	
	2.	JVM 体系结构图：
			a.	类加载器ClassLoader
				- 启动类加载器（Bootstrap）C++

				  负责加载$JAVA_HOME中jre/lib/**rt.jar**里所有的class，由C++实现，不是ClassLoader子类

				- 扩展类加载器（Extension）Java

				  负责加载java平台中**扩展功能**的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

				- 应用程序类加载器（AppClassLoader）Java

				  也叫系统类加载器，负责加载**classpath**中指定的jar包及目录中class

				- 用户自定义加载器  Java.lang.ClassLoader的子类，用户可以定制类的加载方式
				
			双亲委派机制：重点！
				加载类的时候，逐层向上找！找不到在向下找！ 还是找不到则会抛出异常！
				
				作用：防止内存中出现多份同样的字节码!
				
			b.	**Execution Engine**执行引擎负责解释命令，提交操作系统执行。
			
			c.	本地接口Native Interface
					由native 修饰： 底层C,C++ 实现的！
			
			d.	Native Method Stack
					它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。
				
			e.	PC寄存器	
					**用来存储指向下一条指令的地址**
				
			f.	Method Area方法区{非堆}	重点！
					共享区间**。 
					**静态变量+常量+类信息(构造方法/接口定义)+运行时常量池**存在方法区中
					But
					**实例变量存在堆内存**中,和方法区无关
					Stu stu=new Stu(1，"zhang3");
					stu中地址在栈中，(1，"zhang3")在堆中
			g.	栈：
					栈内存，生命周期与线程一致，不存在垃圾回收！
					存储：**8种基本类型的变量+对象的引用变量+实例方法**	重点！
					
					public Class Stu{
						private int id;
						private String name;
					
						public void sayHi(){
							sout("hello word")
						}
					}
					
					Stu stu = new Stu();
					stu.sayHi();
			
					运行原理：
						遵循“先进后出”或者“后进先出”原则。
					
					"Exception in thread "main" java.lang.StackOverflowError"
						细心，细心，细心！看代码！
					
重点：
	堆：
		
	GC：

第一，	堆方法区栈之间的关系！
		
		堆划分：
			新生区：
				伊甸区（Eden space）和幸存者区（Survivor pace）幸存0区 幸存1区 {from ，to}
				创建的对象都在伊甸区： 
				当伊甸园区空间满的时候，程序还需要创建对象时。JVM 就会产生调用回收 普通的GC! 然后将剩下存活的对象放入From 区！
				
				Minor GC GC过程：
				**复制** -> **清空** -> **互换**
				部分对象会在From和To区域中复制来复制去,如此交换15次，进入养老区！
				
			养老区：
				经过15次普通GC 之后的对象！
				养老区满的时候，发生FULL GC{MajorGC}！ 如果依然无法存储对象，此时会发生！就会产生OOM异常“OutOfMemoryError"！
					原因：
						1.	可能堆内存不够，可以通过参数条件 -Xms -Xmx
						2.	存储大量的大对象！这些对象不会被回收！
										
			永久区：
				永久代是方法区(相当于是一个接口interface)的一个实现！ 方法区也叫非堆！
				永久代与元空间的最大区别之处？
				**永久代使用的是jvm的堆内存**，但是java8以后的**元空间**并不在虚拟机中而是**使用本机物理内存**。因此，默认情况下，元空间的大小仅受本地内存限制。
				
			
		堆调优：
			对应的参数：
				| 参数                | 备注                                                   |
				| ------------------- | ------------------------------------------------------ |
				| -Xms                | 初始堆大小。只要启动，就占用的堆大小，默认是内存的1/64 |
				| -Xmx                | 最大堆大小。默认是内存的1/4                            |
				| -Xmn                | 新生区堆大小                                           |
				| -XX:+PrintGCDetails | 输出详细的GC处理日志                                   |
							
			
			System.gc(); 调用它之后，是否会立即执行垃圾回收？
				不会！
				
第二，	GC：分代收集算法
		垃圾判定：
			1.	引用计数法！
				优点：
				- 简单，高效，现在的objective-c、python等用的就是这种算法。

				缺点：
				- 引用和去引用伴随着加减算法，影响性能
				- 很难处理循环引用，相互引用的两个对象则无法释放。
				
				**因此目前主流的Java虚拟机都摒弃掉了这种算法**。

			2.	可达性分析算法!
					判断一个对象是否可以被回收：
						这个对象被标记两次！
							第一次标记：不在 GC Roots 链中，标记为可回收对象。
							第二次标记：判断当前对象是否实现了finalize() 方法，如果没有实现则直接判定这个对象可以回收，
								如果实现了就会先放入一个队列中。并由虚拟机建立一个低优先级的程序去执行它，随后就会进行第二次小规模标记，
								在这次被标记的对象就会真正被回收了！
				
			
			3.	四种引用：
					强引用：	gc 不会动！
					软引用：	当内存快溢出的时候，才会进行回收！
					弱引用：	在下一次垃圾收集之前。
					虚引用：	在回收之前，会得到一个通知！
					
			4.	垃圾回收算法：
					**GC优化 很多时候就是指减少Stop-the-world发生的时间，从而使系统具有高吞吐 、低停顿的特点。**
					
					a.	复制算法:
							优点：
								高效，没有内存碎片！
							缺点：
								浪费内存空间
								想要存活率低的对象，克服50%内存的浪费！
							
							在新生区！
							
					b.	标记清除：
							优点：
								相对复制算法来讲节省了内存空间！
							缺点：
								会扫描两次 
								有内存碎片产生
							在养老区！
					c.	标记压缩:
							优点：
								内存存活对象排列整齐，同样相对复制算法来讲，节省空间！
								
							缺点：
								会扫描两次！
								存活对象过多，那么整理过程效率就会变低！
								
							在养老区！
							
							老年代一般是由[标记清除]或者是[标记清除与标记整理]的混合实现
							
					d.	分代收集算法(Generational-Collection)
							老年代一般是由[标记清除]或者是[标记清除与标记整理]的混合实现
							新生区复制算法！
							
		垃圾收集器：
			1.	Serial/**Serial Old**收集器
					串行：
						新生代：复制算法！
						老年代：标记压缩！
					
			2.	ParNew收集器：
					并行：
						新生代：复制算法！
					串行：
						老年代：标记压缩！
						
			3.	Parallel / Parallel Old 收集器：
					可以通过参数来设置吞吐量！
						新生代复制算法
						老年代标记-压缩
			4.	CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器
					整个过程分为4个步骤，包括：
						- 初始标记（CMS initial mark）
								初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快
								Stop The World
						- 并发标记（CMS concurrent mark）
								并发标记阶段就是进行GC Roots Tracing的过程
						- 重新标记（CMS remark）
								重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
								Stop The World
						- 并发清除（CMS concurrent sweep）
						
						老年代收集器；
						
					**优点**: 并发收集、低停顿
					**缺点**: 产生大量空间碎片、并发阶段会降低吞吐量
					
					"CMS收集器的内存回收过程是与用户线程一起并发地执行"
					
					运行时机：在内存快要耗尽的时候运行！否则会失败！
			
			5.	G1收集器：
					特点：
						1.	并行与并发:
								G1收集器仍然可以通过并发的方式让java程序继续执行。
								
						2.	分代收集：
								G1可以自己管理新生代和老年代了。
							
						3.	空间整合：
								复制算法，标记压缩 这两种算法都意味着G1运作期间不会产生内存空间碎片
								
						4.	可预测的停顿：
								消耗在垃圾收集上的时间不得超过N毫秒！
					
					G1 收集器的运作大致可划分为以下几个步骤：

						1、初始标记（Initial Making）
								标记一下GC Roots能直接关联到的对象，停顿时间较短!
						2、并发标记（Concurrent Marking）
								并发标记阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活对象，这一阶段耗时较长但能与用户线程并发运行！
								
						3、最终标记（Final Marking）
								而最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但可并行执行
								
						4、筛选回收（Live Data Counting and Evacuation）
							
							
			
											
				
			
			
			
			
			
				